# Конфигурации #
    * Системная - уровень системы (все пользователи + все проекты) - установочная директория Git /etc/gitconfig
        $ git config --system

    * Глобальная - уровень пользователя - в домашней директории пользователя файл .gitconfig
        $ git config --global

    * Локальная - уровень репозитория - файл .git/config внутри репо
        $ git config --local (default)

    Посмотреть все настройки и узнать, где они заданы:
        $ git config --list --show-origin
    
    Имя пользователя
        $ git config --global user.name
        $ git config --global user.email
    
    Помощь
        $ git help <command>
        $ git <command> --help
        Пример:
        $ git help config
    
    Краткая помощь
        $ git <command> -h

#############################

# Инициализация репозитория #

    1. Перейти в директорию проекта
    2. Создать пустой репозиторий (делается один раз):
        $ git init
    Репозиторий создан в подкаталоге .git:
        :: Initialized empty Git repository in D:/Courses/Git/.git/
# Разгитить
    rm -rf .git

# Проверить состояние репозитория 
    git status

# Клонирование удалённого репо
    1. Получить ссылку вида https://github.com/YakuninSergey/learning-notes.git
    2. Перейти в нужную папку и клонировать командой:
        $ git clone <ссылка>

        >> $ git clone https://github.com/YakuninSergey/learning-notes.git       
        ::
        Cloning into 'learning-notes'...
        remote: Enumerating objects: 6, done.
        remote: Counting objects: 100% (6/6), done.
        remote: Compressing objects: 100% (3/3), done.
        remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
        Receiving objects: 100% (6/6), done.

# Установка связи локального и уждалённого репо
    1. Перейти в папку с инициированным локальным репо
    2. Ввести команду:
        $ git remote add origin <ссылка на удалённый репо для SSH>
        ссылка на удалённый репо для SSH: 
            git@github.com:<Аккаунт на GitHub - имя в профиле>/<Название репо - название на странице репо>.git
            git@github.com:YakuninSergey/learning-notes.git        
    
    Чтобы проверить установилась ли связь с удалённым репо, ввести команду:
        $ git remote

        >> $ git remote
        :: origin
        
        >> $ git remote -v
        :: origin  git@github.com:YakuninSergey/learning-notes.git (fetch)
        :: origin  git@github.com:YakuninSergey/learning-notes.git (push)


    Для того, чтобы постмотреть URL удалённого репозитория:
        $ git remote get-url origin
        :: https://github.com/YakuninSergey/learning-notes.git


# Подготовить файлы к сохранению 
    $ git add <имя файла>
    $ git add --all
    $ git add .

# Выполнить коммит 
    $ git commit -m <Текст коммента>

# Генерируем SSH-ключ
    При генерации важно использовать только знаение по умолчанию для имени файла, пути и т.д.

    $ ls -la .ssh/ # вывели список созданных ключей в директории .ssh/ находящейся в директори пользователя
    1. Заходим в терминал в директорию .ssh (если там уже есть id_rsa - сохраняем его куда-нибудь отдельно)
        $ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
        или
        $ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
    2. НЕ указываем имя файла - просто жмём Enter. При запросе passphrase просто жмём Enter - т.е. оставляем passphrase пустым
    3. Должны быть созданы 2 файла - id_rsa - один с расширением .pub
    4. Копируем содержимое .pub в буфер обмена
    5. Идём на GitHub в Settings > SSH and GPG keys > SSH keys > New SSH key
    6. Вставляем содержимое .pub в поле
    7. Проверить правильность ключа:
        $ ssh -i <Полный путь к ключу> -T git@github.com
        Путь например: /c/Users/yakun/.ssh/ed25519/2024-11-07_key
        
        Если ключ подходит появится сообщение:
        Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access. 

    8. Добавляем SSH ключ к агенту.
        $ ssh-add c:/Users/YOU/.ssh/id_ed25519

# Отправить изменения на удалённый репозиторий
    $ git push -u origin main

# Получить изменеия с удалённого репо и слить с веткой в локальном
    $ git pull --rebase=true origin main

# Просмотреть лог коммитов
    $ git log
    $ git log --oneline # сокращённый вариант

# HEAD
    HEAD - аналог хеша последнего коммита    

# Изменить последний коммит
    
    Дополнить коммит новыми файлами
        $ git add new_file
        $ git commit --amend --no-edit
            --amend - изменения происходят в последнем коммите
            --no-edit - не менять сообщение коммита
    
    Изменить сообщение коммита 
        $ git commit --amend -m "Изменённое сообщение"

    
# Убрать файл из staged area (из списка на коммит)
    $ git restore --staged <file>
    file - файл, который нужно удалить из списка на коммит

# Откатить коммит 
    $ git reset --hard <commit hash>
    При этом HEAD будет ссылаться на состояние <commit hash>, а всё что было после - удалится

# Откатить изменения для modified (not staged)
    $ git restore <file>
    Команда откатит изменения в файле до последней сохранённой (в коммите или в staging) версии

# Просматриваем изменения в файлах
        $ git diff # только для modifed (not staged)
            Строки --- a/teremok.txt и +++ b/teremok.txt говорят, что дальше будет выведен результат сравнения файлов a/teremok.txt и b/teremok.txt — исходной и текущей версий.
            Строка @@ -1,2 +1,2 @@ сообщает, какие строки файла попали в сравнение. Выражение 1,2 (неважно, с плюсом или с минусом) говорит, что были использованы две строки, начиная с первой. 
            Если бы было, например, написано +15,7, это значило бы, что в сравнении участвуют 7 строк, начиная с 15-й.
            Выражение со знаком минус (-1,2) относится к «оригинальной» версии файла (a/teremok.txt), а со знаком плюс (+1,2) — к «изменённой» (b/teremok.txt).
        
        $ git diff --staged # для staged

        $ git diff <хеш коммита 1> <хеш коммита 2> # покажет изменения которые нужно сделать после коммита 1, для того чтобы получить состояние в коммите 2 
        # <хеш коммита ...> может быть заменён на сокращённое значение полученное с помощью комманды $ git log --oneline

        Суффикс навигации ~
            ~N - N число коммитов назад во времени
            commit~0 - сам коммит
            commit~1 - предыдущий коммит

            HEAD - текущий коммит
            HEAD~ - (без числа) предыдущий коммит перед текущим

            $ git diff HEAD~ HEAD # что изменилось в текущем коммите с момента предыдущего
            $ git diff HEAD HEAD~ # что нужно изменить в текущем коммите, чтобы откатиться к предыдущему


# Fork
    Fork - опреация на GitHub, к Git отношения не имеет.
    Fork создаёт абсолютно независимую от оригинала копию репо на GitHub

# Сделать файл (скрипт) исполняемым
    Имеем скрипт check.sh
    $ chmod +x check.sh # сделать файл исполняемым
    $ ./check.sh # выполнить скрипт

# Ветки
    Ветка - изолированный поток разработки проекта.
    Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.

    Посмотреть ветки проекта
        $ git branch
    
    Создать новую ветку
        $ git branch <имя ветки>
        
        Примеры:
            $ git branch feature/new_func # для нового функционала
            $ git branch bugfix/func # для исправления ошибок
    
    Переключиться на другю ветку
        $ git checkout <название ветки>

        >> $ git checkout feature/add-branch-info
        :: Switched to branch 'feature/add-branch-info'
    
    Создать ветку и сразу переключиться на неё 
        $ git checkout -b <название_ветки>

    Просматриваем все ветки
        $ git branch -a

        Ветки удалённого репо будут иметь перфикс  remotes/origin/
    
    Сравнить ветки 
        $ git diff <название_ветки1> <название_ветки2>
        
        git diff main feature/diff покажет изменения, которые нужны, чтобы получить состояние ветки feature/diff из ветки main, т.е. как из первой ветки получить вторую.

    Слияние веток (Merge)    
        1. Перейти в ту ветку, в которую будет выполняться слияние
        2. $ git merge <название_ветки> # Название той ветки, коммиты которой будут вставлять в активную ветку

    Удалить ветку
        1. Перейти из удаляемой ветки в любую другую
        2. $ git branch -D <название_ветки>

        $ git branch -d %имя_ветки% # удалить ветку только если она была полностью объединена с другой

    
Слияние и удаление веток
    1. Объединяем и удаляем ветки
    2. Что такое конфликт
    3. Практическая работа №3. Учим друга «мёржить» ветки

Работа с ветками в удалённом репозитории
    1. Обратно на GitHub
    2. Создаём pull request
    3. Забираем изменения из удалённого репозитория
    4. Практическая работа №4. Выходим из отпуска — и узнаём, что проект изменился
        
Работа с ветками на практике
    1. Что такое fast-forward
    2. Non-fast-forward
    3. git push и fast-forward
    4. Почему бы не «пушить» всё в main
    5. Модели веток. Простая feature branch модель

Работа с pull request
    1. Pull request и code review
    2. Работа с PR: практика
    3. Работа с PR: soft skills

Конфликты
    1. Разрешение конфликта вручную и через vimdiff
    2. Разрешение конфликта через Visual Studio Code
    3. Что делать, если основная ветка «убежала» вперёд в процессе ревью